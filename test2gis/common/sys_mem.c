//////////////////////////////////////////////////////////////////////////////
/** \file
 	\brief Функции распределения памяти с контролем ошибок
 	
 	Функции распределения памяти с контролем ошибочно заданных параметров, ошибок при изменении размера блока и т.п.
 */

#include "sys_mem.h"

//////////////////////////////////////////////////////////////////////////////
/// Выделение памяти с возможным обнулением. Обертка над malloc. Обнуление производится при помощи memset,
/// в расчете на лучшую оптимизацию компилятором.
/// \param [out] void **mem - указатель на переменную для размещения адреса выделенного массива памяти
/// \param [in] size_t size - размер выделяемого массива памяти
/// \param [in] int zero - признак обнуления памяти (по умолчанию не обнулять)
/// \return EOK (0) в случае успеха
/// \return EINVAL (22) при ошибке в исходных данных
/// \return ENOMEM (12) при ошибке выделения памяти
int malloc_r(void **mem, size_t size, int zero)
{
int result = EINVAL;
void *tmp = NULL;

if(mem && size)
{
	tmp = malloc(size);
	if(tmp)
	{
		if(zero)
			memset(tmp, 0, size);
		result = EOK;
	}
	else
		result = ENOMEM;
	*mem = tmp;
}

return(result);
}
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
/// Перераспределение памяти с возможным обнулением добавленного пространства. Контролируется
/// возвращаемое значение стандартной фунции realloc, с тем, чтобы не потерять уазатель на ранее выделенную
/// память.
/// \param [in, out] void **mem - указатель на переменную для размещения адреса перераспределенного массива памяти
/// \param [in] size_t old_size - текущий размер массива памяти
/// \param [in] size_t new_size - новый размер массива памяти
/// \param [in] int zero - признак обнуления памяти (по умолчанию не обнулять)
/// \return EOK (0) в случае успеха
/// \return EINVAL (22) при ошибке в исходных данных
/// \return ENOMEM (12) при ошибке перераспределения памяти
int realloc_r(void **mem, size_t old_size, size_t new_size, int zero)
{
int result = EINVAL;
void *tmp = NULL;
byte_t *to_zero = NULL;

if(mem && *mem && old_size && new_size)
{
	tmp = *mem;
	tmp = realloc(tmp, new_size);
	if(tmp)
	{
		*mem = tmp;
		if(new_size > old_size && zero)
		{
			to_zero = (byte_t *)tmp + old_size;
			memset(to_zero, 0, new_size - old_size);
		}
		result = EOK;
	}
	else
		result = ENOMEM;
}

return(result);
}
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
/// Освобождение выделенной памяти с возможным обнулением
/// \param [in, out] void **mem - указатель на переменную с адресом освобождаемого массива памяти
/// \param [in] size_t size - размер освобождаемого массива памяти, для обнуления (по умолчанию не обнулять)
/// \return EOK (0) в случае успеха
/// \return EINVAL (22) при ошибке в исходных данных
int free_r(void **mem, size_t size)
{
int result = EINVAL;
void *tmp = NULL;

if(mem && *mem)
{
	tmp = *mem;
	if(size)
		memset(tmp, 0, size);
	free_null(tmp);
	*mem = tmp;
	result = EOK;
}

return(result);
}
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
/// Дублирование строки с выделением памяти под нее, аналог strdup.
/// \param [out] char **dst - указатель на переменную для размещения адреса создаваемой строки
/// \param [in] const char *src - указатель на строку-источник
/// \return EOK (0) в случае успеха
/// \return EINVAL (22) при ошибке в исходных данных
/// \return ENOMEM (12) при ошибке выделения памяти
int strdup_r(char **dst, const char *src)
{
int result = EINVAL;
char *tmp = NULL;
size_t len = 0;

if(dst && src)
{
	len = strlen(src);
	result = DRTSMallocZero(tmp, len+1);
	if(result == EOK)
	{
		if(len)
			strncpy(tmp, src, len+1);
		*dst = tmp;
	}
}

return(result);
}
//////////////////////////////////////////////////////////////////////////////
