#if !defined(__TEXTBASE_H)
#define __TEXTBASE_H

/** \file
	\brief Реализация интерфейса для разбора структурированных текстовых файлов настройки.
	
	Реализация интерфейса для разбора структурированных текстовых файлов настройки на строки, а строк - на поля.
	Файл должен состоять из текстовых строк, поля которых разделены заданными символами (например, табуляцией).
	Поля могут быть заключены в пары символов-ограничителей, например, квадратные скобки [], в этом случае все символы,
	заключенные внутри этих ограничителей, а также сама пара ограничителей, рассматриваются как одно поле, например [это поле].
	
	Кроме того, интерфейс предоставляет средства для разбора простейших математических выражений с константами, например 2+2.
	
	Интерфейс наследуется от базового класса TextFile.

*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <math.h>
#include "textfile.h"

#pragma pack(push,1)

extern "C" {

enum {Empty = 0, Operator, Variable, Number}; //Тип лексемы
enum {No = EOK, Zero = EFAULT, Syntax = EINVAL}; //Значение ошибки

///////////////////////////////////////////////////////////////////////////
///   \brief Базовый класс TextBase предоставляет функции для разбора строк
/// текстового файла на поля.
///   \details Символы-разделители полей могут задаваться.
/// Поля могут быть заключены в пары символов-ограничителей, например, квадратные скобки [], в этом случае все символы,
///	заключенные внутри этих ограничителей, а также сама пара ограничителей, рассматриваются как одно поле, например [это поле].
///	Кроме того, предоставляются средства для разбора простейших математических выражений и возврата результата в виде строки,
/// например TextBase::math_pars("2+2") вернет строку "4"
///
/// В производном классе должна быть переопределена функция TextFile::parse
class TextBase : public TextFile
{
  int divLen;   ///< Длина строки разделителей
  int commLen;  ///< Длина строки коментариев
  int quotLen;  ///< Длина строки символов кавычек
  int parLen;   ///< Длина строки символов парных скобок
  int contLen;  ///< Длина строки символов продолжения строки

protected:

  char *Divider;    ///< Указатель на строку разделителей               
  char *Comment;    ///< Указатель строку коментариев                
  char *Quoter;     ///< Указатель строку символов кавычек           
  char *Parentsess; ///< Указатель строку символов парных скобок     
  char *Continuer;  ///< Указатель строку символов продолжения строки

  char *math_expr; ///< Указатель на рзбираемое выражение
  int math_token_no;   ///< номер очередного элемента математического выражения
  int math_type;   ///< тип очередного элемента математического выражения
  char math_token[MAX_PATH]; ///<Лексема
  int math_err;   ///< ошибка разбора математического выражения

public:
  /// Проверка, является ли данный символ разделителем
  /// \param [in] char a проверяемый символ
  /// \return 1, если символ является разделителем, в противном случае 0
  int isDiv(char a) {  if(memchr(Divider,a,divLen)!=NULL) return 1;
					   else return 0;
					};

  /// Проверка, является ли данный символ началом комментария
  /// \param [in] char b проверяемый символ
  /// \return 1, если символ является началом комментария, в противном случае 0
  int isComment(char b) {
						 if(memchr(Comment,b,commLen)!=NULL) return 1;
						 else return 0;
						};

  /// Проверка, является ли данный символ признаком продолжения строки
  /// \param [in] char b проверяемый символ
  /// \return 1, если символ является признаком продолжения, в противном случае 0
  int isCont(char b) { if(memchr(Continuer,b,contLen)!=NULL) return 1;
               else return 0;
                    };

  /// Проверка, является ли данный символ кавычками
  /// \param [in] char c проверяемый символ
  /// \return указатель на первое вхождение символа, в противном случае NULL
  char *isQuote(char c) { return((char *)memchr(Quoter,c,quotLen));};

  /// Проверка, является ли данный символ одной из парных скобок
  /// \param [in] char c проверяемый символ
  /// \return указатель на первое вхождение символа, в противном случае NULL
  char *isPar(char c)   { return((char *)memchr(Parentsess,c,parLen));};

  /// Считать любой символ из строки-параметра разделителем полей.
  /// по умолчанию используются символы '\t', ' ', '='
  /// \param [in] const char *s строка разделителей
  /// \return нет
  void setDivider(const char *s);

  /// Считать любой символ из строки-параметра символом комментария.
  /// по умолчанию используется символ '#'
  /// \param [in] const char *s строка символов комментария
  /// \return нет
  void setComment(const char *s);

  /// Игнорировать все символы-разделители
  /// внутри пары любого символа из строки-
  /// параметра. Такая пара символов считается
  /// ограничителем поля.
  /// по умолчанию используются одинарные и двойные кавычки
  /// \param [in] const char *s строка символов-кавычек
  /// \return нет
  void setQuoter(const char *s);

  /// То же саме, что setQuoter, но задаются
  /// парные разделители полей. В строке параметров
  /// сначала должны быть первые символы пар
  /// затем вторые, по умолчанию  [{(<]})>
  /// \param [in] const char *s строка парных скобок
  /// \return нет
  void setParentsess(const char *s);

  /// Считать любой символ из строки-параметра символом продолжения строки.
  /// по умолчанию используются символы '+', '\'
  /// \param [in] const char *s строка символов продолжения строки
  /// \return нет
  void setContinuer(const char *s);

  /// Разобрать строку на поля
  /// \param [in] char *str анализируемая строка или NULL для обращения к следующему полю в строке
  /// \return указатель на очередное вхождения поля в строке, либо NULL, если строка закончилась
  char* strtok(char *str);

/// \defgroup math_parse Функции разбора математических выражений
/// @{

  /// Получение лексемы из строки
  /// \param [in] char *expr - строка выражения
  /// \return нет  
  void getToken(char *expr);

  /// Точка входа анализатора математических выражений
  /// \param [in, out] char *line - строка выражения и буфер под строку результата
  /// \return указатель на результат вычислений в виде текста  
  char *math_pars(char *line);

  /// Обрабатывает сложение и вычитание
  /// \param [in] double *anw - значение
  /// \return 0, если выражение обработано  
  /// \return 1, в случае ошибки  
  int fSum(double *anw);

  /// Обрабатывает умножение и деление
  /// \param [in] double *anw - значение
  /// \return 0, если выражение обработано  
  /// \return 1, в случае ошибки  
  int fMulti(double *anw);

  /// Возведение в степень
  /// \param [in] double *anw - значение
  /// \return 0, если выражение обработано  
  /// \return 1, в случае ошибки  
  int fExp(double *anw);

  /// Обработка унарных операторов
  /// \param [in] double *anw - значение
  /// \return 0, если выражение обработано  
  /// \return 1, в случае ошибки  
  int fUnary(double *anw);

  /// Обрабатывает выражение в скобках
  /// \param [in] double *anw - значение
  /// \return 0, если выражение обработано  
  /// \return 1, в случае ошибки  
  int fBrack(double *anw);

  /// Получает значение числа
  /// \param [in] double *anw - значение
  /// \return 0, если выражение обработано  
  /// \return 1, в случае ошибки  
  int fAtom(double *anw);

  /// Функция должна возвращать значение переменной по ее имени в выражении.
  /// Переопределяется в производном классе
  /// \param [in] char *name - имя переменной
  /// \return значение переменной  
  virtual double getMathVar(char *name) {return 0.0;};

/// @}

  /// Конструктор по умолчанию
  TextBase();

  /// Конструктор
  /// \param [in] char *fname имя файла
  /// \param [in] int mode режим открытия файла, по умолчанию только для чтения
  /// \param [in] int access режим доступа к файлу, если он создается, по умолчанию полный доступ
  TextBase(char *fname, int mode = O_RDONLY, int access = 0777);

  /// Деструктор
  ~TextBase();

};

};

#pragma pack(pop)

#endif