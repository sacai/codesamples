#ifndef _APPCMDLINE_
#define _APPCMDLINE_

/** \file
 \brief Базовый класс для разбора командной строки
 
 В данном файле описывается базовый класс, реализующий функции разбора командной строки. Реализация под
 конкретную платформу должна быть определена в производном классе.

*/

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "sys_base.h"
#include "sarray.h"

#pragma pack(push,1)

// Константы, определяющие внешнее представление аргументов

#define DASH_PREFIX       0x01           ///< Префикс ключевого слова - символ '-'
#define SLASH_PREFIX      0x02           ///< Префикс ключевого слова - символ '/'

/// Чувствительность к регистру букв
#define CASE_SENS         0x04

/// Командная строка должна быть представлена в DOS-стиле
#define DOS_LIKE          DASH_PREFIX | SLASH_PREFIX

/// Командная строка должна быть представлена в UNIX-стиле
#define UNIX_LIKE         DASH_PREFIX | CASE_SENS

/// Символы, которые могут отделять ключевое слово от параметра
#define CMD_DIV           ":="

extern "C" {


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Базовый класс для разбора командной строки
/// \details В целях оптимизации может быть отключен разбор аргументов с плавающей
/// запятой при помощи инструкции _NO_FLOAT_ARGS в опциях компилятора
class AppCommandLine : public DRTS_Base_Object
{
protected:

    int count;                       ///< Счетчик аргументов
    unsigned char style;             ///< Внешнее представление аргументов
    int current;                     ///< Текущая позиция в списке аргументов
	sArray opts;                     ///< Список допустимых опций

    /// Проверка очередного аргумента на наличие ключевого слова
    /// \param [in] char *key - ключевое слово
    /// \param [in] char **arg - массив аргументов командной строки
    /// \return
    /// 1, если ключевое слово найдено, в противном случае 0
    int checkKey(char *key, char **arg);

    /// Получить очередной аргумент командной строки. Переопределяется в производном классе.
    /// \param [in] int item - порядковы номер агрумента
    /// \return Функция должна возвращать указатель на аргумент или NULL в случае неуспеха
    virtual char *getArg(int item) {return NULL;};

    /// Скопировать заданное количество символов строки до нуля или перевода строки
    /// \param [out] char *dst - буфер-приемник
    /// \param [in] const char *src - строка-источник
    /// \param size_t n - количество копируемых символов
    /// \return указатель на буфер-приемник или NULL в случае неуспеха
    char *strncpyEx(char *dst, const char *src, size_t n);

public:

    /// Конструктор
	/// \param нет
    AppCommandLine() {opts.init(20); count = 0; style = 0; current = 0;};

    /// Деструктор
	/// \param нет
    ~AppCommandLine() {opts.flush(); count = 0; style = 0; current = 0;};

    /// Получить значение параметра по ключевому слову
    /// в соответствии с заданным форматом
    /// \param [in] const char *key - ключевое слово или символ
    /// \param [in] int next - поиск ведется от начала командной строки (0) либо от последнего найденного аргумента (1)
    /// \param [in] const char *format - строка формата для вычитывания аргумента
    /// \param [out] void *param - указатель на буфер под значение аргумента
    /// \return позиция найденного аргумента в комнандной строке, либо -1 в случае ошибки
    int getParameter(const char *key, int next, const char *format, void *param);

    /// Получить значение строкового параметра
    /// \param [in] const char *key - ключевое слово или символ
    /// \param [in] int next - поиск ведется от начала командной строки (0) либо от последнего найденного аргумента (1)
    /// \param [out] char *param - указатель на строку-приемник значения аргумента
    /// \param [in] unsigned size - размер строки-приемника
    /// \return позиция найденного аргумента в комнандной строке, либо -1 в случае ошибки
    int getStringParameter(const char *key, int next, char *param, unsigned size);

    /// Проверить наличие параметра-флага (без значения)
    /// \param [in] const char *key - ключевое слово или символ
    /// \param [in] int next - поиск ведется от начала командной строки (0) либо от последнего найденного аргумента (1)
    /// \param [out] int *param - указатель на переменную, принимающую значение 1, если параметр найден, и 0 в противном случае
    /// \return позиция найденного аргумента в комнандной строке, либо -1 в случае ошибки
    int getFlagParameter(const char *key, int next, int *param);

    /// Установить количество параметров
    /// \param [in] int cnt - количество параметров
    /// \return нет
    void setCount(int cnt) {count = cnt;};

    /// Получить количество параметров
    /// \param нет
    /// \return количество параметров
    int getCount(void) {return(count);};

    /// Установить внешнее представление аргументов
    /// \param [in] unsigned char s - маска внешнего представления аргументов
    /// \return нет
    void setStyle(unsigned char s) {style = s;};

    /// Установить набор допустимых опций. Если набор был установлен, он дополняется.
    /// \param [in] const char *opt - строка ключей и ключевых слов, разделенных двоеточиями
    /// \return нет
    void setOpt(const char *opt);

};

};

#pragma pack(pop)

#endif