#include "sys_mem.h"
#include "appcmdl.h"
#include "util.h"

///////////////////////////////////////////////////////////////////////////////
/// Проверка очередного аргумента на наличие ключевого слова                  //
/// \param 
/// char *key - ключевое слово
/// \param 
/// char **arg - массив аргументов командной строки
/// \return
/// 1, если ключевое слово найдено, в противном случае 0
///////////////////////////////////////////////////////////////////////////////
int AppCommandLine::checkKey(char *key, char **arg)
{
// Настроим указатель на аргумент
char *argstr = *arg;
int index = 0, i = 0;
// Введем переменную под результат сравнения
int res = -1;
// Проверим наличие ключевого слова
if(key != NULL)
{
    // Ключевое слово задано
	// Определим индекс ключа в списке допустимых ключей
	for(index = 0; index < opts.size(); index++)
	{
		res = -1;
	    if(style & CASE_SENS)
    	    // Сравниваем, учитывая регистр букв
        	res = strcmp(key, opts[index]);
    	else
        	// Сравниваем, не учитывая регистр букв
        	res = Stricmp(key, opts[index]);
		if(!res)
			break;
	}
    // Проверим наличие префикса, соответствующего
    // заданному внешнему представлению
    if((style & DASH_PREFIX && *argstr == '-')
      || (style & SLASH_PREFIX && *argstr == '/'))
    {
        // Пропустим префикс
        argstr++;
        while((style & DASH_PREFIX) && *argstr == '-') argstr++;
        while((style & SLASH_PREFIX) && *argstr == '/') argstr++;
    }
	res = -1;
    if(style & CASE_SENS)
        // Сравниваем, учитывая регистр букв
        res = strncmp(argstr, key, strlen(key));
    else
        // Сравниваем, не учитывая регистр букв
        res = Strnicmp(argstr, key, strlen(key));
    if(!res)
    {
		// Ключевое слово, возможно, найдено, проверим, не совпадает ли текущий ключ с другим
		for(i = 0; i < opts.size(); i++)
		{
			res = -1;
		    if(style & CASE_SENS)
        	    // Сравниваем, учитывая регистр букв
            	res = strncmp(argstr, opts[i], strlen(opts[i]));
        	else
            	// Сравниваем, не учитывая регистр букв
        		res = Strnicmp(argstr, opts[i], strlen(opts[i]));
			if(!res)
			{
				// Если совпадение найдено, и ключ не тот, что мы искали сейчас, выходим с ложным результатом
				if(i != index)
				{
				    if(style & CASE_SENS)
        		    	// Сравниваем, учитывая регистр букв
            			res = strncmp(key, opts[i], strlen(opts[i]));
        			else
            			// Сравниваем, не учитывая регистр букв
           				res = Strnicmp(key, opts[i], strlen(opts[i]));
					if(res < 0)
						return 0;
				}
			}
		}
        // Ключевое слово найдено, настроим указатель на
        // параметр
        argstr+=strlen(key);
        if(*argstr && strchr(CMD_DIV, *argstr))
            argstr++;
        *arg = argstr;
        return 1;
    }
}
else if(key == NULL)
{
    // Проверим наличие префикса, соответствующего
    // заданному внешнему представлению
    if((style & DASH_PREFIX && *argstr == '-')
      || (style & SLASH_PREFIX && *argstr == '/'))
        return 0;
    // Если префикс не обнаружен и при этом не задано ключевое слово,
    // результат будет положительным, поскольку это означает, что
    // был найден параметр без ключа
    return 1;
}
// Ключевое слово не найдено
return 0;
}

///////////////////////////////////////////////////////////////////////////////
/// Получить значение параметра по ключевому слову и заданному формату        //
/// \param 
/// const char *key - ключевое слово или символ
/// int next - поиск ведется от начала командной строки (0) либо от последнего найденного аргумента (1)
/// const char *format - строка формата для вычитывания аргумента
/// void *param - указатель на значение аргумента
/// \return
/// позиция найденного аргумента в комнандной строке, либо -1 в случае ошибки
///////////////////////////////////////////////////////////////////////////////
int AppCommandLine::getParameter(const char *key, int next, const char *format,
                              void *param)
{
char *arg;            // Указатель на текущий просматриваемый аргумент
int found = 0;         // Найден ли искомый параметр
char *keyptr = (char *)key;    // Указатель на ключевое слово
// В зависимости от значения next идем в цикле либо от
// последнего найденного аргумента (позиционный синтаксис),
// либо от начала списка аргументов
for(int i = (next? current+1 : 0);i < count;i++)
{
    // Настроим указатель на текущий аргумент
    arg = getArg(i);
    if(arg != NULL)
    {
        // и проверяем на наличие ключевого слова; если есть,
        // то указатель сдвигается на значение параметра
        found = checkKey(keyptr, &arg);
        if(found)
        {
            if(!*arg)
            {
                // Найден только ключ, будем искать следующий
                // параметр, который не является ключом
                keyptr = NULL;
                continue;
            }
            else if(*arg)
            {
				// Проверим значение аргумента, оно должно быть числовым
                if(!isdigit(*arg) && *arg != '-' && *arg != '+')
					continue;
                // Получить значение можно, только зная формат,
                // который задается по тем же правилам, что и для
                // функций семейства scanf()
                if(*format == '%')
                {
					int scanned = sscanf(arg, format, param);
					if(scanned != 1)
						return -1;
                    // Запомним и вернем индекс обработанного аргумента
                    current = i;
                    return(current);
                }
            }
        }
    }
}
// Если не нашли заданное ключевое слово либо не смогли преобразовать
// значение, вернем признак ошибки
return -1;
}

///////////////////////////////////////////////////////////////////////////////
/// Получить значение строкового параметра                                    //
/// \param 
/// const char *key - ключевое слово или символ
/// int next - поиск ведется от начала командной строки (0) либо от последнего найденного аргумента (1)
/// char *param - указатель на строку-приемник значения аргумента
/// unsigned size - размер строки-приемника
/// \return
/// позиция найденного аргумента в комнандной строке, либо -1 в случае ошибки
///////////////////////////////////////////////////////////////////////////////
int AppCommandLine::getStringParameter(const char *key, int next,
                                    char *param, unsigned size)
{
char *arg;                  // Указатель на текущий просматриваемый аргумент
int found = 0;              // Найден ли искомый параметр                   
char *keyptr = (char *)key;    // Указатель на ключевое слово
// В зависимости от значения next идем в цикле либо от
// последнего найденного аргумента (позиционный синтаксис),
// либо от начала списка аргументов
for(int i = (next? current+1 : 0);i < count;i++)
{
    // Настроим указатель на текущий аргумент
    arg = getArg(i);
    if(arg != NULL)
    {
        // и проверяем на наличие ключевого слова; если есть,
        // то указатель сдвигается на значение параметра
        found = checkKey(keyptr, &arg);
        if(found)
        {
            if(!*arg)
            {
                // Найден только ключ, будем искать следующий
                // параметр, который не является ключом
                keyptr = NULL;
                continue;
            }
            else if(*arg)
            {
                // Копируем в предоставленный буфер
                strncpyEx(param, arg, size);
                // Запомним и вернем индекс обработанного аргумента
                current = i;
                return(current);
            }
        }
    }
}
// Если не нашли заданное ключевое слово либо не смогли преобразовать
// значение, вернем признак ошибки
return -1;
}

///////////////////////////////////////////////////////////////////////////////
/// Проверить наличие параметра-флага                                         //
/// \param 
/// const char *key - ключевое слово или символ
/// int next - поиск ведется от начала командной строки (0) либо от последнего найденного аргумента (1)
/// int *param - указатель на переменную, примиющую значение 1, если параметр найден, и 0 в противном случае
/// \return
/// позиция найденного аргумента в комнандной строке, либо -1 в случае ошибки
///////////////////////////////////////////////////////////////////////////////
int AppCommandLine::getFlagParameter(const char *key, int next, int *param)
{
char *arg;                  // Указатель на текущий просматриваемый аргумент
int found = 0;              // Найден ли искомый параметр                   
// В зависимости от значения next идем в цикле либо от
// последнего найденного аргумента (позиционный синтаксис),
// либо от начала списка аргументов
for(int i = (next? current+1 : 0);i < count;i++)
{
    // Настроим указатель на текущий аргумент
    arg = getArg(i);
    if(arg != NULL)
    {
        // и проверяем на наличие ключевого слова
        found = checkKey((char *)key, &arg);
        if(found)
        {
            // Флаг присутствует в командной строке,
            // заносим 1 в переданный буфер
            *param = 1;
            // Запомним и вернем индекс обработанного аргумента
            current = i;
            return(current);
        }
    }
}
// Если не нашли заданное ключевое слово либо не смогли преобразовать
// значение, вернем признак ошибки
return -1;
}


///////////////////////////////////////////////////////////////////////////////
/// Скопировать заданное количество символов строки до нуля или перевода строки
/// \param 
/// char *dst - буфер-приемник
/// \param 
/// const char *src - строка-источник
/// \param 
/// size_t n - количество копируемых символов
/// \return
/// указатель на буфер-приемник или NULL в случае неуспеха
char *AppCommandLine::strncpyEx(char *dst, const char *src, size_t n)
{
int i = 0;
if(src && dst)
{
    for(i = 0; i < n && i < strlen(src); i++)
    {
        if(src[i] == '\r' || src[i] == '\n')
            break;
        dst[i] = src[i];
    }
    dst[i] = 0;
    return dst;
}
return NULL;
}
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Установить набор допустимых опций
/// \param 
/// const char *opt - строка ключей и ключевых слов, разделенных двоеточиями
/// \return
/// нет
void AppCommandLine::setOpt(const char *opt)
{
if(opt)
{
	int added = 0;
	char *tmpopt = NULL;
	int res = DRTSStrdup(tmpopt, opt);
	if(res == EOK)
	{
		char *curopt = strtok(tmpopt, ":");
		int found, i;
		while(curopt)
		{
			for(i = 0; i < opts.size(); i++)
			{
				if(!strcmp(opts[i], curopt))
					break;
			}
			if(i == opts.size())
			{
				opts.add(curopt);
				added = 1;
			}
			curopt = strtok(NULL, ":");
		}
		if(added)
			opts.sort();
		DRTSFree(tmpopt);
	}
}
}
///////////////////////////////////////////////////////////////////////////////

