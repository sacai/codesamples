/**
  @file Интерфейс для запуска расчетных потоков
  
Общие сведения
 
Интерфейс для запуска расчетных потоков разработан с целью обеспечения реализации выполнения высокоинтенсивных расчетных задач, прозрачную с точки зрения программиста, выполняющего код этих расчетных задач.
Интерфейс предоставляет следующие возможности:
- указание максимального количества вычислительных функций (потоков);
- указание размера стека, выделяемого отдельному потоку при его создании;
- добавление вычислительной функции в список потоков;
- запуск расчета в одном из возможных режимов (см далее) и ожидание завершения расчета.
Расчетные функции могут быть запущены в одном из следующих режимов:
- параллельно, с ожиданием окончания расчета одним из потоков и принудительным завершением всех остальных;
- параллельно, с ожиданием окончания расчета всеми потоками;
- последовательно, от первой к последней позиции в списке, в этом случае возможности распараллеливания не используются.
Расчетной функции предоставляются средства:
- передачи необходимых исходных данных на вход функции;
- установки признака окончания расчета;
- проверки признака принудительного завершения расчета (с завершением потока).
К расчетным функциям предъявляются следующие требования:
- не использовать выделение/освобождение памяти (за исключением стека);
- не использовать функции чтения/записи;
- при использовании общих участков памяти организация блокировок возлагается на разработчика расчетных функций.
Интерфейс реализован на языке C++, с использованием стандартных функций языка C++11. Для запуска потоков используются функции POSIX. Для взаимодействия между потоками и родительским процессом используются атомарные булевские переменные.
В целях портирования на платформы, не поддерживающие POSIX, реализована возможность принудительного отключения распараллеливания на этапе компиляции, в этом случае использование атомарных переменных также отключается.
Тестирование проведено на платформе x86 под управлением операционной системы QNX 6.5, сборка осуществлялась компилятором GCC 4.8.1.

Использование интерфейса

Интерфейс реализован в виде класса mkCalcPool. Объявления конструкторов, методов и переменных класса, а также сервисных функций располагаются в заголовочном файле mkcalcpool.hpp. Описания методов класса и сервисных функций располагаются в файле mkcalcpool.cpp. Таким образом, для использования класса mkCalcPool достаточно подключить заголовочный файл mkcalcpool.hpp в конкретный модуль, а также включить файл mkcalcpool.cpp в состав проекта (makefile).
Для использования возможностей распараллеливания расчета в проекте должна быть определена директива _MK_PARALLEL_ (при помощи #define или флага командной строки компилятора). Если директива не определена, распараллеливание отключается.

Инициализация и закрытие интерфейса

Для инициализации интерфейса необходимо создать объект класса mkCalcPool. Конструктор класса принимает следующие параметры:
mkCalcPool(size_t cnt, size_t stk)
Здесь
cnt - максимальное количество вычислительных функций в списке;
stk - размер стека, выделяемый каждому потоку при параллельном запуске вычислений.
Параметр stk может быть равен 0, в этом случае размер стека остается на усмотрение операционной системы (так, в QNX 6.5 это 132 Кбайт).
Внимание! В программе может быть создан только один экземпляр класса mkCalcPool. При создании второго и более экземпляров функции объекта возвращают ошибку EBUSY (16).
При использовании конструктора по умолчанию объект может быть инициализирован функцией
int Init(size_t cnt, size_t stk)
с аналогичными параметрами. Данная функция возвращает:
EOK (0) в случае успешной инициализации;
ENOMEM (12) в случае ошибки распределения памяти;
EINVAL (22), если максимальное количество вычислительных функций указано равным 0.
По завершении работы с интерфейсом он может быть уничтожен вызовом функции
Free()
либо вызовом деструктора (автоматическим, при создании объекта на стеке, или ручным, при помощи оператора delete, при создании объекта в динамической памяти).

Правила оформления расчетных функций

Расчетная функция должна быть объявлена следующим образом:
void *func(calc_func_data_t *data)
Функция должна принимать на вход указатель на следующую структуру:
struct calc_func_data_t
{
	void *parameter;			///< Указатель на некий параметр функции
	calc_run_mode_t mode;		///< Режим запуска функции
	calc_atomic_flag_t *finished;	///< Указатель на флаг завершения расчета
};
Режим запуска функции может принимать следующие значения:
CRM_INIT (0) - значение, присваимое при инициализации структуры.
CRM_WAIT_ONE (1) - расчет будет запущен в параллельных потоках, с ожиданием завершения одного из потоков закончившего расчет первым. По окончании расчета функция должна установить флаг окончания расчета.
CRM_WAIT_ALL (2) - расчет будет запущен в параллельных потоках, с ожиданием завершения всех потоков. Установка флага завершения расчета желательна, но не обязательна.
CRM_SEQENCE (3) - расчетные функции будут запущены последовательно, без распараллеливания.
Флаг окончания расчета устанавливается при помощи функции (макроса)
SET_FINISHED(calc_atomic_flag_t *ptr)
Здесь
ptr - указатель на флаг завершения расчета, переданный в функцию в структуре calc_func_data_t.
Кроме того, во всех режимах функция должна контролировать признак принудительного прекращения расчета, с немедленным завершением потока. Контроль данного признака производится при помощи функции (макроса)
TST_POINT()
в произвольном месте кода функции.
Кроме того, для контроля признака прекращения расчета в условии цикла for или while может быть использована функция
bool NOT_BREAK(void)
которая возвращает true, если цикл может быть продолжен, или false, если цик расчета должен быть прерван. В последнем случае, при параллельном расчете, функция вызывает завершение потока (pthread_exit).

Добавление расчетных функций в список

Расчетная функция добавляется в конец или в определенное место списка при помощи функции объекта mkCalcPool
int Inject(void *(*f)(calc_func_data_t*), void *p, int ind)
Здесь
f - указатель на расчетную функцию;
p - указатель на параметр, передаваемый функции (см calc_func_data_t::parameter);
ind - порядковый номер ячейки в списке, или -1, если необходимо добавить функцию в первую свободную ячейку.
Функция возвращает:
EOK (0) в случае успеха;
ENOENT (2), если список потоков не инициализирован;
ESRCH (3), если порядковый номер указан неверно (превышает максимальное количество функций);
EAGAIN (11), если свободное место в списке исчерпано.
Если в качестве указателя на расчетную функцию передан NULL, данная позиция в списке будет занята, но не будет никаким образом участвовать в расчете.

Запуск расчета

Расчет запускается при помощи функции объекта mkCalcPool
int Start(calc_run_mode_t mode)
Здесь
mode - режим запуска. Может принимать следующие значения:
CRM_WAIT_ONE (1) - расчет будет запущен в параллельных потоках, с ожиданием завершения одного из потоков, закончившего расчет первым. Остальным потокам буде взведен признак принудительного завершения расчета.
CRM_WAIT_ALL (2) - расчет будет запущен в параллельных потоках, с ожиданием завершения всех потоков.
CRM_SEQENCE (3) - расчетные функции будут запущены последовательно, без распараллеливания.
Внимание! В случае, если директива _MK_PARALLEL_ не определена на этапе компиляции, режим запуска принудительно меняется на CRM_SEQENCE, и обращений к функциям POSIX-потоков не происходит.
Функция Start дожидается окончания вычислений и возвращает:
EOK (0) в случае успеха;
ENOENT (2), если список потоков не инициализирован;
признак ошибки запуска потока, возвращаемый функциями pthread_create или pthread_attr_setstacksize (если определена директива _MK_PARALLEL_).
При включенном распараллеливании расчетные функции запускаются по возможности одновременно. В случае ошибки создания потока, запуск расчетных функций не производится, остальные потоки уничтожаются.

*/

#ifndef _MKCALCPOOL_
#define _MKCALCPOOL_

#include <stdlib.h>
#include <errno.h>

#ifndef EOK
	#ifdef EZERO
		/// Признак успешного выполнения функции
		#define EOK EZERO
	#else
		/// Признак успешного выполнения функции
		#define EOK 0
	#endif
#endif

#ifdef _MK_PARALLEL_

	#include <time.h>
	#if defined(WIN32) || defined(WIN64)
		#include <windows.h>
		#include <process.h>

		/// Тип для идентификатора потока
		typedef HANDLE calc_thread_t;

	#else
		#include <signal.h>
		#include <pthread.h>
		#include <time.h>
		
		/// Тип для идентификатора потока
		typedef pthread_t calc_thread_t;

	#endif
	#include <atomic>

	/// Атомарный флаг для общения между родителем и потоками
	typedef std::atomic_bool	calc_atomic_flag_t;

#else

	/// Атомарный флаг для общения между родителем и потоками
	typedef bool	calc_atomic_flag_t;

	/// Тип для идентификатора потока
	typedef int		calc_thread_t;

#endif


/// Режимы запуска расчетных потоков
enum calc_run_mode_t
{
	CRM_INIT = 0,		///< Искодное значение переменной, ничего не делать
	CRM_WAIT_ONE = 1,	///< Ожидать завершения одного из потоков, затем принудительно завершить остальные
	CRM_WAIT_ALL = 2,	///< Ожидать завершения всех потоков
	CRM_SEQENCE = 3		///< Выполнить функции последовательно, без запуска потоков
};

/// Установка атомарного флага
/// \param calc_atomic_flag_t *ptr - указатель на атомарную переменную
/// \param bool value - значение (true или false)
void SET_ATOM_FLAG(calc_atomic_flag_t *ptr, bool value);

/// Проверка атомарного флага
/// \param calc_atomic_flag_t *ptr - указатель на атомарную переменную
/// \return значение (true или false)
bool GET_ATOM_FLAG(calc_atomic_flag_t *ptr);

/// Данные, передаваемые на вход функции потока
struct calc_func_data_t
{
	void *parameter;				///< Указатель на некий параметр функции
	calc_run_mode_t mode;			///< Режим запуска функции
	calc_atomic_flag_t *finished;	///< Указатель на флаг завершения расчета
};

/// Тип расчетной функции
typedef void *(*calc_func_t)(calc_func_data_t*);


/// Описание потока
class calc_item_t
{
protected:
	calc_thread_t tid;						///< Идентификатор потока
	calc_func_t func;					///< Указатель на расчетную функцию
	calc_func_data_t func_data;			///< Данные, передачаемые на вход функции
	
public:
	/// Конструктор
	/// \param calc_func_t f - указатель на расчетную функцию
	/// \param void *p - параметр функции
	/// \param calc_atomic_flag_t *flg - указатель на флаг завершения расчета
	calc_item_t(calc_func_t f = NULL, void *p = NULL, calc_atomic_flag_t *flg = NULL);

	/// Деструктор
	~calc_item_t();
	
	/// Инициализация объекта
	/// \param uint32_t n - номер потока
	/// \param calc_func_t f - указатель на расчетную функцию
	/// \param void *p - параметр функции
	/// \param calc_atomic_flag_t *flg - указатель на флаг завершения расчета
	/// \return нет
	void init(calc_func_t f = NULL, void *p = NULL, calc_atomic_flag_t *flg = NULL);
	
	/// Закрытие объекта
	/// \param нет
	/// \return нет
	void clear(void);

	/// Установить режим запуска
	/// \param calc_run_mode_t m - режим запуска
	/// \return нет
	void set_mode(calc_run_mode_t m);

	/// Посмотреть текущий режим запуска
	/// \param нет
	/// \return режим запуска
	calc_run_mode_t get_mode(void);

	/// Установить указатель на флаг завершения
	/// \param calc_atomic_flag_t *flg - режим запуска
	/// \return нет
	void set_flag_ptr(calc_atomic_flag_t *flg);

	/// Посмотреть текущий указатель на флаг завершения
	/// \param нет
	/// \return режим запуска
	calc_atomic_flag_t *get_flag_ptr(void);

	/// Установить идентификатор потока
	/// \param calc_thread_t id - идентификатор потока
	/// \return нет
	void set_tid(calc_thread_t id);

	/// Получить текущий идентификатор потока
	/// \param нет
	/// \return идентификатор потока
	calc_thread_t get_tid(void);

	/// Получить указатель на функцию потока
	/// \param нет
	/// \return указатель на функцию потока
	calc_func_t get_func(void);

	/// Получить указатель на данные для функции потока
	/// \param нет
	/// \return указатель на данные для функции потока
	calc_func_data_t *get_func_data(void);
};

/// Класс, обеспечивающий прозрачную, с точки зрения программного кода, реализацию выполнения высокоинтенсивных расчетных задач
class mkCalcPool
{
	static unsigned int in_use;		///< Признак использования, страховка от создания дополнительных экземпляров класса
protected:
	size_t count;					///< Количество потоков
	size_t stacksize;				///< Размер стека, выделяемый одному потоку
	calc_item_t *items; 			///< Массив указателей на описания потоков
	size_t last;					///< Последняя занятая позиция в списке
	calc_thread_t *handles;			///< Массив дескрипторов потоков

#ifdef _MK_PARALLEL_

	timespec pool_start_begin;		///< Точка старта потоков (до момента создания)
	timespec pool_start_end;		///< Точка окончания старта потоков (после входа в расчетную функцию)

	/// Запуск потока
	/// \param calc_item_t *item - указатель на описание потока
	/// \return EOK в cлучае успеха
	/// \return EINVAL, если список указатель на описание потока не инициализирован
	/// \return признак ошибки запуска потока, возвращаемый функцией системы
	int run(calc_item_t *item);


	/// Ожидание в течение заданного числа миллисекунд
	/// \param int Ms - число миллисекунд
	void wait(int Ms);
#endif

public:
	/// Конструктор по умолчанию
	mkCalcPool();

	/// Конструктор
	/// \param size_t cnt - число потоков
	/// \param size_t stk - объем стека на поток (по умолчанию 0 - размер стека устанавливается системой)
	mkCalcPool(size_t cnt, size_t stk = 0);

	/// Деструктор
	~mkCalcPool();
	
	/// Инициализация объекта
	/// \param size_t cnt - число потоков
	/// \param size_t stk - объем стека на поток (по умолчанию 0 - размер стека устанавливается системой)
	/// \return EOK в cлучае успеха
	/// \return ENOMEM при ошибке выделения памяти
	/// \return EINVAL при неверных параметрах
	int Init(size_t cnt, size_t stk = 0);

	/// Добавление функции потока в указанное место
	/// \param void *(*f)(calc_func_data_t*) - указатель на расчетную функцию
	/// \param void *p - параметр функции
	/// \param int ind - порядковый номер в списке потоков (-1 добавляет ункцию в первую свободную ячейку списка)
	/// \return EOK в cлучае успеха
	/// \return ENOENT, если список потоков не инициализирован
	/// \return ESRCH, если порядковый номер указан неверно
	int Inject(void *(*f)(calc_func_data_t*), void *p, int ind = -1);

	/// Запуск расчета
	/// \param calc_run_mode_t mode режим расчета
	/// Если директива _MK_PARALLEL_ не определена, режим расчета принудително будет установлен в последовательный
	/// (CRM_SEQENCE)
	/// \return EOK в cлучае успеха
	/// \return ENOENT, если список потоков не инициализирован
	/// \return признак ошибки запуска потока, возвращаемый функцией pthread_create
	int Start(calc_run_mode_t mode);
	
	/// Очистка ресурсов и закрытие объекта
	/// \param нет
	/// \return нет
	void Free(void);

	/// Получение указателя на список потоков. Обращаться с осторожностью!
	/// \param нет
	/// \return указатель на список потоков или NULL, если таковой не инициализирован
	calc_item_t *getItems(void) {return items;};

	/// Получение количества потоков
	/// \param нет
	/// \return количество потоков
	size_t getCount(void) {return count;};
	
	/// Получить размер стека, выделяемый одному потоку
	/// \param нет
	/// \return размер стека или 0, если стек устанавливается системой
	size_t getStackSize(void) {return stacksize;};
	
	/// Получение последней занятой позиции в списке
	/// \param нет
	/// \return последняя занятая позиция в списке
	size_t getLast(void) {return last;};

	/// Получение указателя на массив дексрипторов потоков
	/// \param нет
	/// \return массив дескрипторов потоков
	calc_thread_t *getHandles(void) {return handles;};

#ifdef _MK_PARALLEL_
	/// Получение точки начала запуска потоков
	/// \param нет
	/// \return время точки старта потоков
	timespec *get_pool_start_begin(void) {return &pool_start_begin;};

	/// Получение точки окончания запуска потоков
	/// \param нет
	/// \return время точки окончания потоков
	timespec *get_pool_start_end(void) {return &pool_start_end;};
#endif
};

/// Признак остановки всех потоков
extern calc_atomic_flag_t calc_stop;

#if defined (_POSIX_BARRIERS) || defined (PTHREAD_BARRIER_SERIAL_THREAD)
/// Барьер для запуска POSIX-потоков
extern pthread_barrier_t *run_barrier;
/// Барьер для остановки POSIX-потоков
extern pthread_barrier_t *fin_barrier;
#endif

/// Проверка флага остановки в условии цикла расчета и немедленный выход из потока
/// \param нет
/// \return true, если цикл может быть продолжен
/// \return false, если цикл должен быть прерван
bool NOT_BREAK(void);

/// Проверка необходимости завершения в цикле потока
#define TST_POINT()	do {NOT_BREAK();} while(0)

/// Установка флага завершения расчета
/// \param calc_atomic_flag_t *ptr - указатель на флаг завершени расчета
#define SET_FINISHED(ptr) do {SET_ATOM_FLAG(ptr, true);} while(0)

#endif